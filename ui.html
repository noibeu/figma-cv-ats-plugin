<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CV ATS Export</title>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 16px;
      background: #ffffff;
    }

    h2 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #000000;
    }

    button {
      width: 100%;
      padding: 10px 16px;
      background: #18A0FB;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #1591E6;
    }

    button:active {
      background: #0D7DC6;
    }

    button:disabled {
      background: #CCCCCC;
      cursor: not-allowed;
    }

    .info {
      background: #F0F0F0;
      padding: 12px;
      border-radius: 4px;
      font-size: 11px;
      color: #333333;
      margin-bottom: 16px;
      line-height: 1.4;
    }

    .info strong {
      display: block;
      margin-bottom: 4px;
      color: #000000;
    }
  </style>
</head>
<body>
  <h2>Export ATS-compliant PDF</h2>

  <div class="info">
    <strong>📋 2-page PDF:</strong>
    Page 1: Perfect visual design<br>
    Page 2: Structured text for ATS
  </div>

  <button id="export-btn">Export as ATS PDF</button>

  <script>
    const exportBtn = document.getElementById('export-btn');

    // Send message to main code to start export
    exportBtn.addEventListener('click', () => {
      exportBtn.disabled = true;
      exportBtn.textContent = 'Exporting...';

      parent.postMessage({
        pluginMessage: { type: 'export-ats-pdf' }
      }, '*');
    });

    // Receive data and generate PDF
    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;

      if (msg.type === 'generate-pdf') {
        try {
          exportBtn.textContent = 'Generating PDF...';

          const { pngBytes, frameWidth, frameHeight, textBlocks } = msg.data;

          console.log('=== DATA RECEIVED ===');
          console.log('PNG bytes:', pngBytes?.length);
          console.log('Frame:', frameWidth, 'x', frameHeight);
          console.log('Texts:', textBlocks?.length);

          if (!pngBytes || pngBytes.length === 0) {
            throw new Error('Missing PNG image');
          }

          // Convert Array to Uint8Array
          const pngBytesArray = new Uint8Array(pngBytes);

          // Create PDF with pdf-lib
          const { PDFDocument, rgb, StandardFonts } = PDFLib;
          const pdfDoc = await PDFDocument.create();

          // A4 format: 595 x 842 points
          const page = pdfDoc.addPage([595, 842]);
          const { width: pageWidth, height: pageHeight } = page.getSize();

          // 1. EMBED PNG IMAGE (exact visual rendering)
          const pngImage = await pdfDoc.embedPng(pngBytesArray);
          const pngDims = pngImage.scale(1);

          // Calculate scale to fit image in A4 page with margins
          const margin = 40;
          const availableWidth = pageWidth - 2 * margin;
          const availableHeight = pageHeight - 2 * margin;

          const scale = Math.min(
            availableWidth / pngDims.width,
            availableHeight / pngDims.height
          );

          const scaledWidth = pngDims.width * scale;
          const scaledHeight = pngDims.height * scale;

          // Center image on page
          const imageX = (pageWidth - scaledWidth) / 2;
          const imageY = (pageHeight - scaledHeight) / 2;

          // Draw PNG image
          page.drawImage(pngImage, {
            x: imageX,
            y: imageY,
            width: scaledWidth,
            height: scaledHeight
          });

          console.log('✅ Page 1 (PNG Image) created:', {
            original: `${pngDims.width}x${pngDims.height}`,
            scaled: `${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}`,
            scale: scale.toFixed(3),
            position: `(${imageX.toFixed(0)}, ${imageY.toFixed(0)})`
          });

          // 2. CREATE PAGE 2: STRUCTURED TEXT FOR ATS
          if (textBlocks && textBlocks.length > 0) {
            const page2 = pdfDoc.addPage([595, 842]);
            const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

            // Text cleaning function
            function cleanText(text) {
              return text
                .replace(/[\u2028\u2029]/g, ' ')
                .replace(/[\u00A0\u1680\u2000-\u200B\u202F\u205F\u3000]/g, ' ')
                .replace(/[\u2018\u2019]/g, "'")
                .replace(/[\u201C\u201D]/g, '"')
                .replace(/[\u2013\u2014]/g, '-')
                .replace(/\u2026/g, '...')
                .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            }

            // Optimize reading order (columns)
            function optimizeReadingOrder(blocks) {
              // Detect if 2-column layout
              const midX = frameWidth / 2;
              const leftCol = blocks.filter(b => b.x < midX);
              const rightCol = blocks.filter(b => b.x >= midX);

              if (leftCol.length > 0 && rightCol.length > 0) {
                // 2 columns: read left then right
                const sortedLeft = leftCol.sort((a, b) => a.y - b.y);
                const sortedRight = rightCol.sort((a, b) => a.y - b.y);
                return [...sortedLeft, ...sortedRight];
              }

              // 1 column: top → bottom
              return blocks.sort((a, b) => {
                const yDiff = a.y - b.y;
                return Math.abs(yDiff) > 5 ? yDiff : a.x - b.x;
              });
            }

            // Group by sections
            function groupBySections(blocks) {
              const sections = [];
              let currentSection = { type: 'HEADER', title: null, texts: [] };

              for (const block of blocks) {
                if (block.isTitle) {
                  // Save previous section
                  if (currentSection.texts.length > 0 || currentSection.title) {
                    sections.push(currentSection);
                  }
                  // New section
                  currentSection = {
                    type: block.sectionType || 'OTHER',
                    title: cleanText(block.text),
                    texts: []
                  };
                } else {
                  currentSection.texts.push(cleanText(block.text));
                }
              }

              // Add last section
              if (currentSection.texts.length > 0 || currentSection.title) {
                sections.push(currentSection);
              }

              return sections;
            }

            // Draw text with word wrap
            function drawTextWithWrap(page, text, x, startY, maxWidth, fontSize, font) {
              const words = text.split(' ');
              let line = '';
              let currentY = startY;
              const lineHeight = fontSize * 1.4;

              for (const word of words) {
                const testLine = line + word + ' ';
                const lineWidth = font.widthOfTextAtSize(testLine, fontSize);

                if (lineWidth > maxWidth && line !== '') {
                  // Line full
                  page.drawText(line.trim(), {
                    x: x,
                    y: currentY,
                    size: fontSize,
                    font: font,
                    color: rgb(0, 0, 0)
                  });
                  currentY -= lineHeight;
                  line = word + ' ';
                } else {
                  line = testLine;
                }
              }

              // Last line
              if (line.trim()) {
                page.drawText(line.trim(), {
                  x: x,
                  y: currentY,
                  size: fontSize,
                  font: font,
                  color: rgb(0, 0, 0)
                });
                currentY -= lineHeight;
              }

              return currentY;
            }

            // Generate page 2 content
            const orderedBlocks = optimizeReadingOrder(textBlocks);
            const sections = groupBySections(orderedBlocks);

            let currentY = pageHeight - 60;
            const marginX = 50;
            const maxWidth = pageWidth - 2 * marginX;

            for (const section of sections) {
              // Section title (BOLD, UPPERCASE)
              if (section.title) {
                const titleSize = section.type === 'HEADER' ? 18 : 14;

                page2.drawText(section.title.toUpperCase(), {
                  x: marginX,
                  y: currentY,
                  size: titleSize,
                  font: helveticaBoldFont,
                  color: rgb(0, 0, 0)
                });
                currentY -= titleSize * 1.8;
              }

              // Section texts
              for (const text of section.texts) {
                if (!text) continue;

                currentY = drawTextWithWrap(
                  page2,
                  text,
                  marginX,
                  currentY,
                  maxWidth,
                  11,
                  helveticaFont
                );

                currentY -= 5; // Spacing between paragraphs
              }

              currentY -= 15; // Spacing between sections

              // New page if necessary
              if (currentY < 80) {
                const newPage = pdfDoc.addPage([595, 842]);
                currentY = pageHeight - 60;
              }
            }

            console.log(`✅ Page 2 (ATS Text) created: ${sections.length} sections detected`);
          }

          // 3. ATS-FRIENDLY METADATA
          // Extract candidate name (first text with fontSize > 20)
          let candidateName = 'CV';
          const headerBlock = textBlocks.find(b => b.fontSize > 20);
          if (headerBlock) {
            candidateName = headerBlock.text.trim();
          }

          pdfDoc.setTitle(`CV - ${candidateName}`);
          pdfDoc.setAuthor(candidateName);
          pdfDoc.setSubject('Curriculum Vitae - ATS Optimized');
          pdfDoc.setKeywords(['CV', 'Resume', 'Curriculum Vitae', 'ATS', 'Application', candidateName]);
          pdfDoc.setProducer('Figma ATS Export Plugin v2.0');
          pdfDoc.setCreator('Figma ATS Plugin');
          pdfDoc.setCreationDate(new Date());

          console.log(`✅ Metadata: CV of ${candidateName}`);

          // 4. SAVE AND DOWNLOAD
          const pdfBytes = await pdfDoc.save();

          const blob = new Blob([pdfBytes], { type: 'application/pdf' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;

          // File name based on candidate name
          const fileName = `cv-${candidateName.toLowerCase().replace(/\s+/g, '-')}.pdf`;
          a.download = fileName;

          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          console.log(`✅ PDF "${fileName}" downloaded successfully`);
          console.log('📄 Page 1: Visual design (PNG image)');
          console.log('📄 Page 2: Structured text for ATS');

          // Re-enable button
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export as ATS PDF';
        } catch (error) {
          console.error('❌ PDF error:', error);
          alert('Error: ' + error.message);
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export as ATS PDF';
        }
      }
    };
  </script>
</body>
</html>
